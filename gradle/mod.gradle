apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'com.matthewprenger.cursegradle'
apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'jacoco'
apply plugin: 'maven-publish'
apply plugin: 'idea'
apply plugin: 'eclipse'

if (project.file("local.gradle").exists()) {
    apply from "local.gradle"
}

repositories {
    jcenter()
    mavenCentral()
    maven {
        name 'LDTTeam - Modding'
        url 'https://ldtteam.jfrog.io/ldtteam/modding/'
    }
    flatDir {
        dirs {
            "libs"
        }
    }
}

group = project.modGroup
version = project.exactMinecraftVersion + "-" + (System.getenv().containsKey("Version") ? System.getenv("Version") : project.modVersion)
archivesBaseName = project.modId

project.logger.lifecycle("Starting Gradle build for: " + project.modId + " with version: " + project.version)

def projectHasApi = true;
if (project.hasProperty("projectHasApi")) {
    projectHasApi = projectHasApi.toString().toLowerCase() == "true"
}


def defaultSourceSetConfigurationDependencies = new HashSet<String>();
def availableSourceSets = new LinkedHashSet<String>();
def sourceSetConfigurationDependencies = new HashMap<String, Set<String>>();
def sourceSetSourceSetDependencies = new HashMap<String, Set<String>>();
def sourceSetAdditionalResourceDirectories = new HashMap<String, Set<String>>();
def sourceSetExcludedResourceDefinitions = new HashMap<String, Set<String>>();
def sourceSetIncludedResourceDefinitions = new HashMap<String, Set<String>>();

defaultSourceSetConfigurationDependencies.add("minecraft");

if (projectHasApi) {
    availableSourceSets.add("api");
}
availableSourceSets.add("main");
availableSourceSets.add("test");

if (projectHasApi) {
    sourceSetConfigurationDependencies.put("api", defaultSourceSetConfigurationDependencies);
}

sourceSetSourceSetDependencies.put("main", Collections.singleton("api"));
sourceSetSourceSetDependencies.put("test", Collections.singleton("api"));

sourceSetAdditionalResourceDirectories.put("main", Collections.singleton("src/datagen/generated/${project.modId}"))
sourceSetExcludedResourceDefinitions.put("main", Collections.singleton(".cache"))
sourceSetIncludedResourceDefinitions.put("main", Collections.singleton("**/**"))

if (project.hasProperty("extendDefaultSourceSetConfiguration") && project.extendDefaultSourceSetConfiguration.toString().toLowerCase() == "true") {
    def additionalAvailableSourceSets = new HashSet<String>();
    if (project.hasProperty("additionalSourceSets")) {
        Arrays.stream(project.additionalSourceSets.split(";")).forEach(additionalAvailableSourceSets::add)
    }

    availableSourceSets.addAll(additionalAvailableSourceSets);
    additionalAvailableSourceSets.forEach(customSourceSetName -> {
        def configurationDependenciesPropertyName = customSourceSetName + "ConfigurationDependencies"
        def sourceSetDependenciesPropertyName = customSourceSetName + "SourceSetDependencies"
        def additionalResourcesPropertyName = customSourceSetName + "ResourceDirectories"
        def excludeResourcesPropertyName = customSourceSetName + "ExcludedResources"
        def includeResourcesPropertyName = customSourceSetName + "IncludedResources"

        if (project.hasProperty[configurationDependenciesPropertyName]) {
            sourceSetConfigurationDependencies.computeIfAbsent(customSourceSetName, newName -> new HashSet<String>())
            Arrays.stream(project[configurationDependenciesPropertyName].split(";")).forEach(sourceSetConfigurationDependencies.get(customSourceSetName)::add)
        }

        if (project.hasProperty[sourceSetDependenciesPropertyName]) {
            sourceSetSourceSetDependencies.computeIfAbsent(customSourceSetName, newName -> new HashSet<String>())
            Arrays.stream(project[sourceSetDependenciesPropertyName].split(";")).forEach(sourceSetSourceSetDependencies.get(customSourceSetName)::add)
        }

        if (project.hasProperty[additionalResourcesPropertyName]) {
            sourceSetAdditionalResourceDirectories.computeIfAbsent(customSourceSetName, newName -> new HashSet<String>())
            Arrays.stream(project[additionalResourcesPropertyName].split(";")).forEach(sourceSetAdditionalResourceDirectories.get(customSourceSetName)::add)
        }

        if (project.hasProperty[excludeResourcesPropertyName]) {
            sourceSetExcludedResourceDefinitions.computeIfAbsent(customSourceSetName, newName -> new HashSet<String>())
            Arrays.stream(project[excludeResourcesPropertyName].split(";")).forEach(sourceSetExcludedResourceDefinitions.get(customSourceSetName)::add)
        }

        if (project.hasProperty[includeResourcesPropertyName]) {
            sourceSetIncludedResourceDefinitions.computeIfAbsent(customSourceSetName, newName -> new HashSet<String>())
            Arrays.stream(project[includeResourcesPropertyName].split(";")).forEach(sourceSetIncludedResourceDefinitions.get(customSourceSetName)::add)
        }
    })
}

availableSourceSets.forEach(sourceSetName -> {
    def sourceSet = project.sourceSets.maybeCreate(sourceSetName)

    sourceSet.java.srcDir "src/${sourceSetName}/java"
    sourceSet.resources.srcDir "src/${sourceSetName}/resources"

    if (sourceSetConfigurationDependencies.containsKey(sourceSetName)) {
        def configurationDependencies = sourceSetConfigurationDependencies.get(sourceSetName);
        configurationDependencies.forEach(configurationName -> {
            sourceSet.compileClasspath += project.configurations.getByName(configurationName);
        })
    }

    if (sourceSetSourceSetDependencies.containsKey(sourceSetName)) {
        def sourceSetDependencies = sourceSetSourceSetDependencies.get(sourceSetName)
        sourceSetDependencies.forEach(otherSourceSetName -> {
            def otherSourceSet = project.sourceSets[otherSourceSetName]

            sourceSet.compileClasspath += otherSourceSet.output;
            sourceSet.runtimeClasspath += otherSourceSet.output;
        })
    }

    if (sourceSetIncludedResourceDefinitions.containsKey(sourceSetName)) {
        def includeDefinitions = sourceSetIncludedResourceDefinitions.get(sourceSetName)
        includeDefinitions.forEach(definition -> {
            sourceSet.resources.include definition
        })
    }

    if (sourceSetAdditionalResourceDirectories.containsKey(sourceSetName)) {
        def additionalResourceDirectories = sourceSetAdditionalResourceDirectories.get(sourceSetName);
        additionalResourceDirectories.forEach(directory -> {
            sourceSet.resources.srcDirs += directory
        })
    }

    if (sourceSetExcludedResourceDefinitions.containsKey(sourceSetName)) {
        def excludeDefinitions = sourceSetExcludedResourceDefinitions.get(sourceSetName)
        excludeDefinitions.forEach(definition -> {
            sourceSet.resources.exclude definition
        })
    }
})

configurations {
    contained {
        transitive = false
    }
}

if (project.useJavaToolChains.toString().toLowerCase() == "true") {
    java.toolchain.languageVersion = JavaLanguageVersion.of(project.javaVersion)
} else {
    sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = project.javaVersion
}

def primaryJarSourceSets = new HashSet<String>()
if (projectHasApi) {
    primaryJarSourceSets.add("api")
}
primaryJarSourceSets.add("main")
if (project.hasProperty("primaryJarSourceSets")) {
    primaryJarSourceSets.clear();
    Arrays.stream(project.primaryJarSourceSets.split(";")).forEach(sourceSetName -> primaryJarSourceSets.add(sourceSetName as String))
}

minecraft {
    mappings channel: project.mappingsChannel, version: project.mappingsVersion
    accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

    runs {
        client {
            workingDirectory project.file('run')
            property 'forge.logging.markers', ''
            property 'forge.logging.console.level', 'info'
            mods { n ->
                def mod = n.create(project.modId);
                primaryJarSourceSets.forEach(sourceSetName -> {
                    def sourceSet = project.sourceSets[sourceSetName]
                    mod.source(sourceSet)
                })
            }
        }

        server {
            workingDirectory project.file('run')
            property 'forge.logging.markers', ''
            property 'forge.logging.console.level', 'info'
            mods { n ->
                def mod = n.create(project.modId);
                primaryJarSourceSets.forEach(sourceSetName -> {
                    def sourceSet = project.sourceSets[sourceSetName]
                    mod.source(sourceSet)
                })
            }
        }

        data {
            workingDirectory project.file('run')
            property 'forge.logging.markers', ''
            property 'forge.logging.console.level', 'info'
            args '--all', '--output', file("src/datagen/generated/${project.modId}"),
                    '--mod', "${project.modId}".toString(),
                    '--existing', sourceSets.main.resources.srcDirs[0]
            mods { n ->
                def mod = n.create(project.modId);
                primaryJarSourceSets.forEach(sourceSetName -> {
                    def sourceSet = project.sourceSets[sourceSetName]
                    mod.source(sourceSet)
                })
            }
        }
    }
}


def useDefaultTestSystem = true;
def testSourceSets = new HashSet<String>();
def annotatedSourceSets = availableSourceSets;

testSourceSets.add("test");

if (project.hasProperty("useDefaultTestSystem") && project.useDefaultTestSystem.toString().toLowerCase() != "true") {
    useDefaultTestSystem = false;
}
if (project.hasProperty("testSourceSets")) {
    testSourceSets.clear();
    Arrays.stream(project.testSourceSets.split(";")).forEach(sourceSetName -> testSourceSets.add(sourceSetName as String))
}
if (project.hasProperty("annotatedSourceSets")) {
    annotatedSourceSets.clear();
    Arrays.stream(project.annotatedSourceSets.split(";")).forEach(sourceSetName -> annotatedSourceSets.add(sourceSetName as String))
}

if (useDefaultTestSystem) {
    def jUnitVersion = "4.11"
    def mockitoCoreVersion = "1.+"
    def powerMockModuleJUnit4Version = "1.6.5"
    def powerMockApiMockitoVersion = "1.6.5"
    def powerMockModuleJUnit4RuleEngineVersion = "1.6.5"
    def assertJCoreVersion = "3.9.0"
    def hamcrestAllVersion = "1.3"

    if (project.hasProperty("jUnitVersion")) {
        jUnitVersion = project.jUnitVersion;
    }
    if (project.hasProperty("mockitoCoreVersion")) {
        mockitoCoreVersion = project.mockitoCoreVersion;
    }
    if (project.hasProperty("powerMockVersion")) {
        powerMockModuleJUnit4Version = project.powerMockVersion;
        powerMockApiMockitoVersion = project.powerMockVersion;
        powerMockModuleJUnit4RuleEngineVersion = project.powerMockVersion;
    }
    if (project.hasProperty("powerMockModuleJUnit4Version")) {
        powerMockModuleJUnit4Version = project.powerMockModuleJUnit4Version;
    }
    if (project.hasProperty("powerMockApiMockitoVersion")) {
        powerMockApiMockitoVersion = project.powerMockApiMockitoVersion;
    }
    if (project.hasProperty("powerMockModuleJUnit4RuleEngineVersion")) {
        powerMockModuleJUnit4RuleEngineVersion = project.powerMockModuleJUnit4RuleEngineVersion;
    }
    if (project.hasProperty("assertJCoreVersion")) {
        assertJCoreVersion = project.assertJCoreVersion;
    }
    if (project.hasProperty("hamcrestAllVersion")) {
        hamcrestAllVersion = project.hamcrestAllVersion;
    }

    testSourceSets.forEach(sourceSetName -> {
        def configurationName = sourceSetName + "Implementation"
        if (sourceSetName == "main") {
            configurationName = "implementation"
        }

        dependencies.add(configurationName,  "junit:junit:${jUnitVersion}");
        dependencies.add(configurationName,  "org.mockito:mockito-core:${mockitoCoreVersion}");
        dependencies.add(configurationName,  "org.powermock:powermock-module-junit4:${powerMockModuleJUnit4Version}");
        dependencies.add(configurationName,  "org.powermock:powermock-api-mockito:${powerMockApiMockitoVersion}");
        dependencies.add(configurationName,  "org.powermock:powermock-module-junit4-rule-agent:${powerMockModuleJUnit4RuleEngineVersion}");
        dependencies.add(configurationName,  "org.assertj:assertj-core:${assertJCoreVersion}");
        dependencies.add(configurationName,  "org.hamcrest:hamcrest-all:${hamcrestAllVersion}");
    })
}

def intelliJAnnotationsVersion = "21.0.1"
if (project.hasProperty("intelliJAnnotationsVersion")) {
    intelliJAnnotationsVersion = project.intelliJAnnotationsVersion;
}

annotatedSourceSets.forEach(sourceSetName -> {
    def configurationName = sourceSetName + "Implementation"
    if (sourceSetName == "main") {
        configurationName = "implementation"
    }

    dependencies.add(configurationName,  "org.jetbrains:annotations:${intelliJAnnotationsVersion}");
})

dependencies {
    minecraft "net.minecraftforge:forge:${project.exactMinecraftVersion}-${project.forgeVersion}"
}

def primaryJarClassifier = 'universal'
if (project.hasProperty("primaryJarClassifier")) {
    primaryJarClassifier = project.primaryJarClassifier;
}

def automaticModuleName = project.modId
if (project.hasProperty("automaticModuleName")) {
    automaticModuleName = project.automaticModuleName;
}

def projectUsesShadowing = false
if ((project.hasProperty("shadowJar") && project.shadowJar.toString().toLowerCase() == "true") ||
        (project.hasProperty("shadowRenamedNamespaces") &&  !project.shadowRenamedNamespaces.trim().isEmpty())
) {
    projectUsesShadowing = true
}

jar {
    primaryJarSourceSets.forEach(sourceSetName -> {
        project.jar.from project.sourceSets[sourceSetName].output
    })

    classifier primaryJarClassifier
    if (projectUsesShadowing) {
        classifier 'slim'
    }

    manifest {
        attributes([
                'Maven-Artifact'          : "${project.group}:${project.archivesBaseName}:${project.version}",
                "Specification-Title"     : project.modId,
                "Specification-Vendor"    : "ldtteam",
                "Specification-Version"   : "1", // We are version 1 of ourselves
                "Implementation-Title"    : project.name,
                "Implementation-Version"  : "${project.version}",
                "Implementation-Vendor"   : "ldtteam",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                "Automatic-Module-Name"   : automaticModuleName
        ])
    }
}

def additionalSourceSetJars = new HashSet<String>();
if (projectHasApi) {
    additionalSourceSetJars.add("api")
}
if (project.hasProperty("additionalSourceSetJars")) {
    additionalSourceSetJars.clear();
    Arrays.stream(project.additionalSourceSetJars.split(";")).forEach(sourceSetName -> additionalSourceSetJars.add(sourceSetName as String))
}

additionalSourceSetJars.forEach(additionalSourceSet -> {
    String additionalSourceSetJavaDocTaskName = additionalSourceSet + "Javadoc"
    String additionalSourceSetPackageJavaDocTaskName = additionalSourceSet + "PackageJavadoc"
    String additionalSourceSetJarTaskName = additionalSourceSet + "Jar"
    String additionalSourceSetSourcesTaskName = additionalSourceSet + "Sources"
    String additionalSourceSetBuildTask = additionalSourceSet + "Build"

    String additionalSourceSetJavadocClassifier = additionalSourceSet.toLowerCase() + "-javadoc"
    String additionalSourceSetSourcesClassifier = additionalSourceSet.toLowerCase() + "-sources"

    org.gradle.api.tasks.javadoc.Javadoc javaDocTask = project.tasks.create(additionalSourceSetJavaDocTaskName, Javadoc.class);
    javaDocTask.setClasspath(sourceSets[additionalSourceSet].getCompileClasspath())
    javaDocTask.group 'documentation'
    javaDocTask.source = sourceSets[additionalSourceSet].allJava

    org.gradle.api.tasks.bundling.Jar javadocJarTask = project.tasks.create(additionalSourceSetPackageJavaDocTaskName, org.gradle.api.tasks.bundling.Jar.class)
    javadocJarTask.dependsOn javaDocTask
    javadocJarTask.group 'packaging'
    javadocJarTask.from javaDocTask
    javadocJarTask.getArchiveClassifier().set(additionalSourceSetJavadocClassifier)

    org.gradle.api.tasks.bundling.Jar outputJarTask = project.tasks.create(additionalSourceSetJarTaskName, org.gradle.api.tasks.bundling.Jar.class)
    outputJarTask.group 'build'
    outputJarTask.from sourceSets[additionalSourceSet].output
    outputJarTask.getArchiveClassifier().set(additionalSourceSet.toLowerCase())

    org.gradle.api.tasks.bundling.Jar sourcesJarTask = project.tasks.create(additionalSourceSetSourcesTaskName, org.gradle.api.tasks.bundling.Jar.class)
    sourcesJarTask.group 'sources'
    sourcesJarTask.duplicatesStrategy 'exclude'
    sourcesJarTask.from sourceSets[additionalSourceSet].allJava
    sourcesJarTask.getArchiveClassifier().set(additionalSourceSetSourcesClassifier)

    Task sourceSetBuildTask = project.tasks.create(additionalSourceSetBuildTask)
    sourceSetBuildTask.group 'build'
    sourceSetBuildTask.dependsOn javaDocTask
    sourceSetBuildTask.dependsOn javadocJarTask
    sourceSetBuildTask.dependsOn outputJarTask
    sourceSetBuildTask.dependsOn sourcesJarTask

    project.tasks.build.dependsOn sourceSetBuildTask
})

task sourcesJar(type: Jar) { it ->
    classifier = 'sources'
    duplicatesStrategy 'exclude'

    primaryJarSourceSets.forEach(sourceSetName -> {
        it.from project.sourceSets[sourceSetName].allSource
    })
}

javadoc {it ->
    primaryJarSourceSets.forEach(sourceSetName -> {
        it.source +=  project.sourceSets[sourceSetName].allJava
    })
}

task packageJavadoc(type: Jar) {
    from javadoc
    classifier = 'javadoc'
}

project.tasks.build.dependsOn sourcesJar
project.tasks.build.dependsOn packageJavadoc


if (projectUsesShadowing) {
    shadowJar { it ->
        primaryJarSourceSets.forEach(sourceSetName -> {
            it.from project.sourceSets[sourceSetName].output
        })

        configurations = [project.configurations.contained]

        if (!project.shadowRenamedNamespaces.trim().isEmpty()) {
            project.shadowRenamedNamespaces.split(',').each { n ->
                if (n.contains(':')) {
                    def namespaceSpecs = n.split(':');
                    relocate n[0], n[1]
                }
            }
        }

        classifier = primaryJarClassifier
    }
}


def reobfuscationSourceSets = new HashSet<String>();
if (projectHasApi) {
    reobfuscationSourceSets.add("api");
}
reobfuscationSourceSets.add("main");
if (project.hasProperty("reobfuscationSourceSets")) {
    reobfuscationSourceSets.clear();
    Arrays.stream(project.reobfuscationSourceSets.split(";")).forEach(sourceSetName -> reobfuscationSourceSets.add(sourceSetName as String))
}

def reobfuscationContainer = project.reobf
reobfuscationSourceSets.forEach(sourceSetName -> {
    def sourceSet = project.sourceSets[sourceSetName]
    def taskName = sourceSetName + "Jar"
    if (sourceSetName == "main") {
        taskName = "jar"
    }

    def task = reobfuscationContainer.create(taskName)
    task.getClasspath().from(sourceSet.getCompileClasspath())
    task.group 'reobfuscation'

    if (sourceSetName == "main" && projectUsesShadowing) {
        taskName = "shadowJar"
        def shadowTask = reobfuscationContainer.create(taskName)
        shadowTask.group 'reobfuscation'
        shadowTask.getClasspath().from(sourceSet.getCompileClasspath())
    }
})

def publishableSourceSets = new HashSet<String>()
if (projectHasApi) {
    publishableSourceSets.add("api")
}
publishableSourceSets.add("main")
if (project.hasProperty("publishableSourceSets")) {
    publishableSourceSets.clear();
    Arrays.stream(project.publishableSourceSets.split(";")).forEach(sourceSetName -> publishableSourceSets.add(sourceSetName as String))
}

artifacts { it ->
    publishableSourceSets.forEach(sourceSetName -> {
        String javaDocTaskName = sourceSetName + "PackageJavadoc"
        String jarTaskName = sourceSetName + "Jar"
        String sourceTaskName = sourceSetName + "Sources"
        if (sourceSetName == "main") {
            javaDocTaskName = "packageJavadoc"
            jarTaskName = "jar"
            sourceTaskName = "sourcesJar"
        }

        it.add("default", project.tasks[javaDocTaskName])
        it.add("default", project.tasks[jarTaskName])
        it.add("default", project.tasks[sourceTaskName])

        if (sourceSetName == "main" && projectUsesShadowing) {
            it.add("default", project.tasks.shadowJar);
        }
    })
}

publishing {
    publications {
        mavenJava(MavenPublication) {pub ->
            from project.components.java

            publishableSourceSets.forEach(sourceSetName -> {
                String javaDocTaskName = sourceSetName + "PackageJavadoc"
                String jarTaskName = sourceSetName + "Jar"
                String sourceTaskName = sourceSetName + "Sources"
                if (sourceSetName == "main") {
                    javaDocTaskName = "packageJavadoc"
                    jarTaskName = "jar"
                    sourceTaskName = "sourcesJar"
                }

                pub.artifacts.artifact(project.tasks[javaDocTaskName])
                if (sourceSetName != "main") {
                    pub.artifacts.artifact(project.tasks[jarTaskName])
                }
                pub.artifacts.artifact(project.tasks[sourceTaskName])

                if (sourceSetName == "main" && projectUsesShadowing) {
                    pub.artifacts.artifact(project.tasks.shadowJar);
                }
            })

            pom {
                url = project.githubUrl
                licenses {
                    license {
                        name = 'GNU GENERAL PUBLIC LICENSE Version 3'
                        url = 'https://www.gnu.org/licenses/gpl-3.0.en.html'
                    }
                }
                developers {
                    developer {
                        id = 'OrionDevelopment'
                        name = 'Marc Hermans'
                        email = 'marc.hermans@ldtteam.com'
                    }
                    developer {
                        id = 'Raycoms'
                        name = 'Ray Neiheiser'
                        email = 'ray.neiheiser@ldtteam.com'
                    }
                }
                contributors {
                    contributor {
                        id = 'ldtteam'
                        name = 'Let\'s Develop Together - Team'
                        email = 'info@ldtteam.com'
                    }
                }
                scm {
                    connection = project.gitUrl
                    developerConnection = project.gitConnectUrl
                    url = project.projectUrl
                }
            }

            //Replace all deobf dependencies with normal jar references.
            pom.withXml { xmlProvider ->
                def dependencies = asNode().dependencies
                def allDeps = dependencies.'*';

                // Remove forge deps
                allDeps.findAll() { el ->
                    el.artifactId.text() == 'forge' && el.groupId.text() == 'net.minecraftforge'
                }.forEach() { el ->
                    el.parent().remove(el)
                }
                //remove forgegradle's mapped suffix from versions & set as optional so anyone else doesn't inherit them
                allDeps.findAll() { el ->
                    el.version.text().contains('_mapped_')
                }.each { el ->
                    def version = el.version
                    version.each {
                        it.setValue(it.text().substring(0, it.text().indexOf('_mapped_')))
                    }
                }
            }
        }
    }

    if (System.getenv().containsKey("LDTTeamJfrogUsername") && System.getenv().containsKey("LDTTeamJfrogPassword")) {
        repositories {
            maven {
                name 'LDTTeamJfrog'
                credentials {
                    username System.getenv().get("LDTTeamJfrogUsername")
                    password System.getenv().get("LDTTeamJfrogPassword")
                }
                url 'https://ldtteam.jfrog.io/ldtteam/mods-maven'
            }
        }
    }

    repositories {
        maven {
            name 'RepoDirectory'
            url 'file://' + rootProject.file('repo').getAbsolutePath()
        }
    }
}

task setupDecompWorkspace {
    doLast {
        project.logger.log(LogLevel.DEBUG, "FG3+ does not require to setup a decomp workspace")
    }
}

task setupCIWorkspace {
    doLast {
        project.logger.log(LogLevel.DEBUG, "FG3+ does not require to setup a CI workspace")
    }
}

curseforge { cf ->
    if (System.getenv().CURSEAPIKEY != null && System.getenv().CURSERELEASETYPE != null) {
        apiKey = System.getenv().CURSEAPIKEY

        project {
            id = project.curseId
            addGameVersion project.exactMinecraftVersion
            changelog = file('build/changelog.md')
            changelogType = 'markdown'
            releaseType = System.getenv().CURSERELEASETYPE

            if (!project.additionalMinecraftVersions.trim().isEmpty()) {
                project.additionalMinecraftVersions.split(",").each { v ->
                    addGameVersion v
                }
            }

            if (projectUsesShadowing) {
                mainArtifact shadowJar
            } else {
                mainArtifact jar
            }

            publishableSourceSets.forEach(sourceSetName -> {
                String javaDocTaskName = sourceSetName + "PackageJavadoc"
                String jarTaskName = sourceSetName + "Jar"
                String sourceTaskName = sourceSetName + "Sources"
                if (sourceSetName == "main") {
                    javaDocTaskName = "packageJavadoc"
                    jarTaskName = "jar"
                    sourceTaskName = "sourcesJar"
                }

                cf.addArtifact(project.tasks[javaDocTaskName])
                if (sourceSetName != "main" || projectUsesShadowing) {
                    cf.addArtifact(project.tasks[jarTaskName])
                }
                cf.addArtifact(project.tasks[sourceTaskName])
            })
        }
    }
}

task("createChangelog") {
    group = 'upload'

    doLast {
        def teamCityURL = "https://buildsystem.ldtteam.com/"
        def file = new FileOutputStream("build/changelog.md")
        def out = new BufferedOutputStream(file)
        def changesXML = new XmlSlurper().parse(teamCityURL + "guestAuth/app/rest/changes?locator=build:(id:" + teamcity["teamcity.build.id"] + ")")

        def changes = changesXML.change
        println("createChangelog: Identified " + changes.size() + " changes to be written into the changelog.")

        out << "# ${project.modId} Changelog \n"
        out << "## Version: _" + version + "_ \n"

        if (changes.size() > 0) {
            for (int i = 0; i < changes.size(); i++) {
                def changeDetailsURL = teamCityURL + "guestAuth/app/rest/changes/id:" + changes[i].@id.text()
                def changeDetailsXml = new XmlSlurper().parse(changeDetailsURL)
                def changeComment = changeDetailsXml.comment.text().trim()

                out << "* " + changeComment + "\n"
            }
        } else {
            out << "No Changes detected!"
        }

        out.close()
    }
}

idea {
    module {
        inheritOutputDirs = true
    }
}

